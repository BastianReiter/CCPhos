ls_MonitorMetaData_All),
.f = function(TrackData,
MonitorMetaData)
{
if (purrr::is_empty(TrackData) == FALSE)
{
Summary <- TrackData %>%
mutate(across(everything(), ~ as.character(.x))) %>%      # Turn all columns into character (necessary for pivot_longer() to work correctly)
tidyr::pivot_longer(cols = c(everything(), -TrackID),
names_to = c("Feature", "Stage"),
names_sep = "(__)",      # Separate by '__'-string (two underscores)
values_to = "Value") %>%
distinct(pick(c(everything(), -TrackID)), .keep_all = TRUE) %>%
tidyr::pivot_wider(names_from = Stage,
values_from = Value) %>%
select(-TrackID)
#                 rename(Value_Raw = Raw,
#                        Value_Transformed = Transformed,
#                        Value_Final = Final) %>%
#                 rowwise() %>%
#                 mutate(IsOccurring = TRUE,
#                        IsEligible_Raw = Value_Raw %in% MonitorMetaData[[Feature]],
#                        IsEligible_Transformed = Value_Transformed %in% MonitorMetaData[[Feature]]) %>%
#                 ungroup()
#
# # Add set of all eligible values regardless of occurrence to summary
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# for (i in 1:length(MonitorMetaData))   # Loop through all monitored features of a table
# {
#     AllEligibleValues <- tibble(Feature = names(MonitorMetaData)[i],
#                                 Value_Raw = MonitorMetaData[[i]],
#                                 IsOccurring = FALSE,
#                                 IsEligible_Raw = TRUE,
#                                 IsEligible_Transformed = TRUE)
#
#     Summary <- bind_rows(Summary,
#                          AllEligibleValues)
# }
#
# # Filter out eligible values marked as not occurring if they actually occur
# # Result: All eligible values are included in summary, regardless of occurrence
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Summary <- Summary %>%
#                group_by(Feature, Value_Raw) %>%
#                    arrange(desc(IsOccurring), .by_group = TRUE) %>%
#                    slice_head() %>%
#                ungroup() %>%
#                arrange(Feature,
#                        desc(IsOccurring),
#                        desc(IsEligible_Raw),
#                        desc(IsEligible_Transformed),
#                        Value_Raw)
#
# return(Summary)
}
else { return (data.frame()) }
})
View(ls_TransformationTracks_Summaries$Staging)
# Summarize Transformation Tracks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_TransformationTracks_Summaries <- purrr::pmap(.l = list(ls_TransformationTracks,
ls_MonitorMetaData_All),
.f = function(TrackData,
MonitorMetaData)
{
if (purrr::is_empty(TrackData) == FALSE)
{
Summary <- TrackData %>%
mutate(across(everything(), ~ as.character(.x))) %>%      # Turn all columns into character (necessary for pivot_longer() to work correctly)
tidyr::pivot_longer(cols = c(everything(), -TrackID),
names_to = c("Feature", "Stage"),
names_sep = "(__)",      # Separate by '__'-string (two underscores)
values_to = "Value")
# distinct(pick(c(everything(), -TrackID)), .keep_all = TRUE) %>%
# tidyr::pivot_wider(names_from = Stage,
#                    values_from = Value) %>%
# select(-TrackID)
#                 rename(Value_Raw = Raw,
#                        Value_Transformed = Transformed,
#                        Value_Final = Final) %>%
#                 rowwise() %>%
#                 mutate(IsOccurring = TRUE,
#                        IsEligible_Raw = Value_Raw %in% MonitorMetaData[[Feature]],
#                        IsEligible_Transformed = Value_Transformed %in% MonitorMetaData[[Feature]]) %>%
#                 ungroup()
#
# # Add set of all eligible values regardless of occurrence to summary
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# for (i in 1:length(MonitorMetaData))   # Loop through all monitored features of a table
# {
#     AllEligibleValues <- tibble(Feature = names(MonitorMetaData)[i],
#                                 Value_Raw = MonitorMetaData[[i]],
#                                 IsOccurring = FALSE,
#                                 IsEligible_Raw = TRUE,
#                                 IsEligible_Transformed = TRUE)
#
#     Summary <- bind_rows(Summary,
#                          AllEligibleValues)
# }
#
# # Filter out eligible values marked as not occurring if they actually occur
# # Result: All eligible values are included in summary, regardless of occurrence
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Summary <- Summary %>%
#                group_by(Feature, Value_Raw) %>%
#                    arrange(desc(IsOccurring), .by_group = TRUE) %>%
#                    slice_head() %>%
#                ungroup() %>%
#                arrange(Feature,
#                        desc(IsOccurring),
#                        desc(IsEligible_Raw),
#                        desc(IsEligible_Transformed),
#                        Value_Raw)
#
# return(Summary)
}
else { return (data.frame()) }
})
View(ls_TransformationTracks_Summaries$Staging)
# Summarize Transformation Tracks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_TransformationTracks_Summaries <- purrr::pmap(.l = list(ls_TransformationTracks,
ls_MonitorMetaData_All),
.f = function(TrackData,
MonitorMetaData)
{
if (purrr::is_empty(TrackData) == FALSE)
{
Summary <- TrackData %>%
mutate(across(everything(), ~ as.character(.x))) %>%      # Turn all columns into character (necessary for pivot_longer() to work correctly)
tidyr::pivot_longer(cols = c(everything(), -TrackID),
names_to = c("Feature", "Stage"),
names_sep = "(__)",      # Separate by '__'-string (two underscores)
values_to = "Value") %>%
distinct(pick(c(everything(), -TrackID)), .keep_all = TRUE)
# tidyr::pivot_wider(names_from = Stage,
#                    values_from = Value) %>%
# select(-TrackID)
#                 rename(Value_Raw = Raw,
#                        Value_Transformed = Transformed,
#                        Value_Final = Final) %>%
#                 rowwise() %>%
#                 mutate(IsOccurring = TRUE,
#                        IsEligible_Raw = Value_Raw %in% MonitorMetaData[[Feature]],
#                        IsEligible_Transformed = Value_Transformed %in% MonitorMetaData[[Feature]]) %>%
#                 ungroup()
#
# # Add set of all eligible values regardless of occurrence to summary
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# for (i in 1:length(MonitorMetaData))   # Loop through all monitored features of a table
# {
#     AllEligibleValues <- tibble(Feature = names(MonitorMetaData)[i],
#                                 Value_Raw = MonitorMetaData[[i]],
#                                 IsOccurring = FALSE,
#                                 IsEligible_Raw = TRUE,
#                                 IsEligible_Transformed = TRUE)
#
#     Summary <- bind_rows(Summary,
#                          AllEligibleValues)
# }
#
# # Filter out eligible values marked as not occurring if they actually occur
# # Result: All eligible values are included in summary, regardless of occurrence
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Summary <- Summary %>%
#                group_by(Feature, Value_Raw) %>%
#                    arrange(desc(IsOccurring), .by_group = TRUE) %>%
#                    slice_head() %>%
#                ungroup() %>%
#                arrange(Feature,
#                        desc(IsOccurring),
#                        desc(IsEligible_Raw),
#                        desc(IsEligible_Transformed),
#                        Value_Raw)
#
# return(Summary)
}
else { return (data.frame()) }
})
View(ls_TransformationTracks_Summaries$Staging)
# Summarize Transformation Tracks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_TransformationTracks_Summaries <- purrr::pmap(.l = list(ls_TransformationTracks,
ls_MonitorMetaData_All),
.f = function(TrackData,
MonitorMetaData)
{
if (purrr::is_empty(TrackData) == FALSE)
{
Summary <- TrackData %>%
mutate(across(everything(), ~ as.character(.x))) %>%      # Turn all columns into character (necessary for pivot_longer() to work correctly)
tidyr::pivot_longer(cols = c(everything(), -TrackID),
names_to = c("Feature", "Stage"),
names_sep = "(__)",      # Separate by '__'-string (two underscores)
values_to = "Value") %>%
#distinct(pick(c(everything(), -TrackID)), .keep_all = TRUE)
distinct()
# tidyr::pivot_wider(names_from = Stage,
#                    values_from = Value) %>%
# select(-TrackID)
#                 rename(Value_Raw = Raw,
#                        Value_Transformed = Transformed,
#                        Value_Final = Final) %>%
#                 rowwise() %>%
#                 mutate(IsOccurring = TRUE,
#                        IsEligible_Raw = Value_Raw %in% MonitorMetaData[[Feature]],
#                        IsEligible_Transformed = Value_Transformed %in% MonitorMetaData[[Feature]]) %>%
#                 ungroup()
#
# # Add set of all eligible values regardless of occurrence to summary
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# for (i in 1:length(MonitorMetaData))   # Loop through all monitored features of a table
# {
#     AllEligibleValues <- tibble(Feature = names(MonitorMetaData)[i],
#                                 Value_Raw = MonitorMetaData[[i]],
#                                 IsOccurring = FALSE,
#                                 IsEligible_Raw = TRUE,
#                                 IsEligible_Transformed = TRUE)
#
#     Summary <- bind_rows(Summary,
#                          AllEligibleValues)
# }
#
# # Filter out eligible values marked as not occurring if they actually occur
# # Result: All eligible values are included in summary, regardless of occurrence
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Summary <- Summary %>%
#                group_by(Feature, Value_Raw) %>%
#                    arrange(desc(IsOccurring), .by_group = TRUE) %>%
#                    slice_head() %>%
#                ungroup() %>%
#                arrange(Feature,
#                        desc(IsOccurring),
#                        desc(IsEligible_Raw),
#                        desc(IsEligible_Transformed),
#                        Value_Raw)
#
# return(Summary)
}
else { return (data.frame()) }
})
View(ls_TransformationTracks_Summaries$Staging)
# Summarize Transformation Tracks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_TransformationTracks_Summaries <- purrr::pmap(.l = list(ls_TransformationTracks,
ls_MonitorMetaData_All),
.f = function(TrackData,
MonitorMetaData)
{
if (purrr::is_empty(TrackData) == FALSE)
{
Summary <- TrackData %>%
mutate(across(everything(), ~ as.character(.x))) %>%      # Turn all columns into character (necessary for pivot_longer() to work correctly)
tidyr::pivot_longer(cols = c(everything(), -TrackID),
names_to = c("Feature", "Stage"),
names_sep = "(__)",      # Separate by '__'-string (two underscores)
values_to = "Value") %>%
#distinct(pick(c(everything(), -TrackID)), .keep_all = TRUE)
distinct() %>%
tidyr::pivot_wider(names_from = Stage,
values_from = Value) %>%
select(-TrackID)
#                 rename(Value_Raw = Raw,
#                        Value_Transformed = Transformed,
#                        Value_Final = Final) %>%
#                 rowwise() %>%
#                 mutate(IsOccurring = TRUE,
#                        IsEligible_Raw = Value_Raw %in% MonitorMetaData[[Feature]],
#                        IsEligible_Transformed = Value_Transformed %in% MonitorMetaData[[Feature]]) %>%
#                 ungroup()
#
# # Add set of all eligible values regardless of occurrence to summary
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# for (i in 1:length(MonitorMetaData))   # Loop through all monitored features of a table
# {
#     AllEligibleValues <- tibble(Feature = names(MonitorMetaData)[i],
#                                 Value_Raw = MonitorMetaData[[i]],
#                                 IsOccurring = FALSE,
#                                 IsEligible_Raw = TRUE,
#                                 IsEligible_Transformed = TRUE)
#
#     Summary <- bind_rows(Summary,
#                          AllEligibleValues)
# }
#
# # Filter out eligible values marked as not occurring if they actually occur
# # Result: All eligible values are included in summary, regardless of occurrence
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Summary <- Summary %>%
#                group_by(Feature, Value_Raw) %>%
#                    arrange(desc(IsOccurring), .by_group = TRUE) %>%
#                    slice_head() %>%
#                ungroup() %>%
#                arrange(Feature,
#                        desc(IsOccurring),
#                        desc(IsEligible_Raw),
#                        desc(IsEligible_Transformed),
#                        Value_Raw)
#
# return(Summary)
}
else { return (data.frame()) }
})
View(ls_TransformationTracks_Summaries$Staging)
# Summarize Transformation Tracks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_TransformationTracks_Summaries <- purrr::pmap(.l = list(ls_TransformationTracks,
ls_MonitorMetaData_All),
.f = function(TrackData,
MonitorMetaData)
{
if (purrr::is_empty(TrackData) == FALSE)
{
Summary <- TrackData %>%
mutate(across(everything(), ~ as.character(.x))) %>%      # Turn all columns into character (necessary for pivot_longer() to work correctly)
tidyr::pivot_longer(cols = c(everything(), -TrackID),
names_to = c("Feature", "Stage"),
names_sep = "(__)",      # Separate by '__'-string (two underscores)
values_to = "Value") %>%
#distinct(pick(c(everything(), -TrackID)), .keep_all = TRUE)
distinct()
# tidyr::pivot_wider(names_from = Stage,
#                    values_from = Value) %>%
# select(-TrackID)
#                 rename(Value_Raw = Raw,
#                        Value_Transformed = Transformed,
#                        Value_Final = Final) %>%
#                 rowwise() %>%
#                 mutate(IsOccurring = TRUE,
#                        IsEligible_Raw = Value_Raw %in% MonitorMetaData[[Feature]],
#                        IsEligible_Transformed = Value_Transformed %in% MonitorMetaData[[Feature]]) %>%
#                 ungroup()
#
# # Add set of all eligible values regardless of occurrence to summary
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# for (i in 1:length(MonitorMetaData))   # Loop through all monitored features of a table
# {
#     AllEligibleValues <- tibble(Feature = names(MonitorMetaData)[i],
#                                 Value_Raw = MonitorMetaData[[i]],
#                                 IsOccurring = FALSE,
#                                 IsEligible_Raw = TRUE,
#                                 IsEligible_Transformed = TRUE)
#
#     Summary <- bind_rows(Summary,
#                          AllEligibleValues)
# }
#
# # Filter out eligible values marked as not occurring if they actually occur
# # Result: All eligible values are included in summary, regardless of occurrence
# #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Summary <- Summary %>%
#                group_by(Feature, Value_Raw) %>%
#                    arrange(desc(IsOccurring), .by_group = TRUE) %>%
#                    slice_head() %>%
#                ungroup() %>%
#                arrange(Feature,
#                        desc(IsOccurring),
#                        desc(IsEligible_Raw),
#                        desc(IsEligible_Transformed),
#                        Value_Raw)
#
# return(Summary)
}
else { return (data.frame()) }
})
View(ls_TransformationTracks_Summaries$Staging)
# Summarize Transformation Tracks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_TransformationTracks_Summaries <- purrr::pmap(.l = list(ls_TransformationTracks,
ls_MonitorMetaData_All),
.f = function(TrackData,
MonitorMetaData)
{
if (purrr::is_empty(TrackData) == FALSE)
{
Summary <- TrackData %>%
mutate(across(everything(), ~ as.character(.x))) %>%      # Turn all columns into character (necessary for pivot_longer() to work correctly)
tidyr::pivot_longer(cols = c(everything(), -TrackID),
names_to = c("Feature", "Stage"),
names_sep = "(__)",      # Separate by '__'-string (two underscores)
values_to = "Value") %>%
tidyr::pivot_wider(names_from = Stage,
values_from = Value) %>%
select(-TrackID) %>%
distinct() %>%
rename(Value_Raw = Raw,
Value_Transformed = Transformed,
Value_Final = Final) %>%
rowwise() %>%
mutate(IsOccurring = TRUE,
IsEligible_Raw = Value_Raw %in% MonitorMetaData[[Feature]],
IsEligible_Transformed = Value_Transformed %in% MonitorMetaData[[Feature]]) %>%
ungroup()
# Add set of all eligible values regardless of occurrence to summary
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
for (i in 1:length(MonitorMetaData))   # Loop through all monitored features of a table
{
AllEligibleValues <- tibble(Feature = names(MonitorMetaData)[i],
Value_Raw = MonitorMetaData[[i]],
IsOccurring = FALSE,
IsEligible_Raw = TRUE,
IsEligible_Transformed = TRUE)
Summary <- bind_rows(Summary,
AllEligibleValues)
}
# Filter out eligible values marked as not occurring if they actually occur
# Result: All eligible values are included in summary, regardless of occurrence
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Summary <- Summary %>%
group_by(Feature, Value_Raw) %>%
arrange(desc(IsOccurring), .by_group = TRUE) %>%
slice_head() %>%
ungroup() %>%
arrange(Feature,
desc(IsOccurring),
desc(IsEligible_Raw),
desc(IsEligible_Transformed),
Value_Raw)
return(Summary)
}
else { return (data.frame()) }
})
View(ls_TransformationTracks_Summaries$Staging)
# Create final summaries of transformation monitoring for Output
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   - Joining of info from transformation tracks and value counts
#-------------------------------------------------------------------------------
ls_TransformationMonitors <- purrr::pmap(.l = list(ls_TransformationTracks_Summaries,
ls_ValueCounts_Raw,
ls_ValueCounts_Transformed,
ls_ValueCounts_Final),
.f = function(TransformationTracksSummary,
ValueCountsRaw,
ValueCountsTransformed,
ValueCountsFinal)
{
if (nrow(TransformationTracksSummary) > 0)
{
TransformationTracksSummary %>%
left_join(ValueCountsRaw, by = c("Feature", "Value_Raw")) %>%
left_join(ValueCountsTransformed, by = c("Feature", "Value_Transformed")) %>%
left_join(ValueCountsFinal, by = c("Feature", "Value_Final")) %>%
mutate(Count_Transformed = case_when(IsOccurring == FALSE ~ NA,
TRUE ~ Count_Transformed),
Count_Final = case_when(IsOccurring == FALSE ~ NA,
TRUE ~ Count_Final)) %>%
arrange(Feature,
desc(IsOccurring),
desc(IsEligible_Raw),
desc(IsEligible_Transformed),
Value_Raw)
}
else { return(NULL) }
})
View(ls_TransformationMonitors$Staging)
ls_MonitorMetaData_Diagnosis
is.null(ls_MonitorMetaData_Diagnosis$ICD10Version)
devtools::load_all(".")
devtools::load_all(".")
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
# Sub-sample test data for easier testing
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NumberOfPatients <- 1000
# Get a random sample of PatientIDs
SamplePatientIDs <- sample(RawDataSet$patient$"_id",
size = NumberOfPatients)
# Get data subsets that relate to sampled PatientIDs
RawDataSet <- list(sample = as.data.frame(filter(RawDataSet$sample, RawDataSet$sample$"patient-id" %in% SamplePatientIDs)),
diagnosis = as.data.frame(filter(RawDataSet$diagnosis, RawDataSet$diagnosis$"patient-id" %in% SamplePatientIDs)),
histology = as.data.frame(filter(RawDataSet$histology, RawDataSet$histology$"patient-id" %in% SamplePatientIDs)),
metastasis = as.data.frame(filter(RawDataSet$metastasis, RawDataSet$metastasis$"patient-id" %in% SamplePatientIDs)),
"molecular-marker" = as.data.frame(filter(RawDataSet$"molecular-marker", RawDataSet$"molecular-marker"$"patient-id" %in% SamplePatientIDs)),
patient = as.data.frame(filter(RawDataSet$patient, RawDataSet$patient$"_id" %in% SamplePatientIDs)),
progress = as.data.frame(filter(RawDataSet$progress, RawDataSet$progress$"patient-id" %in% SamplePatientIDs)),
"radiation-therapy" = as.data.frame(filter(RawDataSet$"radiation-therapy", RawDataSet$"radiation-therapy"$"patient-id" %in% SamplePatientIDs)),
tnm = as.data.frame(filter(RawDataSet$tnm, RawDataSet$tnm$"patient-id" %in% SamplePatientIDs)),
surgery = as.data.frame(filter(RawDataSet$surgery, RawDataSet$surgery$"patient-id" %in% SamplePatientIDs)),
"system-therapy" = as.data.frame(filter(RawDataSet$"system-therapy", RawDataSet$"system-therapy"$"patient-id" %in% SamplePatientIDs)))
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_TableNames$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_TableNames$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
# Curate data
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
RuleProfile_RawDataTransformation.S = "Default",
RuleProfile_DiagnosisRedundancy.S = "Default",
RuleProfile_DiagnosisAssociation.S = "Default")
View(CurationOutput$CurationReport$Transformation$Staging)
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_TableNames$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_TableNames$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
# Curate data
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
RuleProfile_RawDataTransformation.S = "Default",
RuleProfile_DiagnosisRedundancy.S = "Default",
RuleProfile_DiagnosisAssociation.S = "Default")
View(CurationOutput$CurationReport$Transformation$Staging)
View(CurationOutput$CurationReport$Transformation$Diagnosis)
devtools::load_all(".")
library(dsCCPhos)
