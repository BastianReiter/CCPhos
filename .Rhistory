mutate(OriginalDiagnosisID = DiagnosisID,
DiagnosisID = paste0(DiagnosisID, "/", HistologyID)) %>%
relocate(DiagnosisID, .after = PatientID) %>%
group_by(PatientID) %>%
mutate(PatientCountInitialEntries = n()) %>%
ungroup()
# Names of features that are required to compile rule calls from dsCCPhos::RuleSet_DiagnosisRedundancy
PredictorFeatures_DiagnosisRedundancy = c("CountDeviatingValues",
"InitialDiagnosisDate",
"ICD10Code",
"ICDOTopographyCode",
"LocalizationSide",
"HistologyDate",
"ICDOMorphologyCode",
"Grading")
# Pass required information to dsCCPhos::CompileClassificationCall to compile rull calls (dplyr::case_when-Statements)
Call_IsLikelyRedundant <- CompileClassificationCall(TargetFeature = "IsLikelyRedundant",
PredictorFeatures = PredictorFeatures_DiagnosisRedundancy,
RuleSet = dsCCPhos::RuleSet_DiagnosisRedundancy,
RuleProfile = RuleProfile_DiagnosisRedundancy,
ValueIfNoRuleMet = FALSE)
# Make list of rule calls to pass them to function
RuleCalls_DiagnosisRedundancy <- list(IsLikelyRedundant = Call_IsLikelyRedundant)
# Set up progress bar
CountProgressItems <- df_CDS_Diagnosis %>% filter(PatientCountInitialEntries > 1) %>% pull(PatientID) %>% n_distinct()
ProgressBar <- progress_bar$new(format = "Classifying redundant diagnosis entries [:bar] :percent in :elapsed  :spin",
total = CountProgressItems, clear = FALSE, width= 100)
# Filter patients with multiple diagnosis entries and apply dsCCPhos::ClassifyDiagnosisRedundancy()
df_Aux_Diagnosis_ClassifiedRedundancies <- df_CDS_Diagnosis %>%
filter(PatientCountInitialEntries > 1) %>%
group_by(PatientID) %>%
group_modify(~ ClassifyDiagnosisRedundancy(DiagnosisEntries = .x,
RuleCalls = RuleCalls_DiagnosisRedundancy,
ProgressBarObject = ProgressBar)) %>%
ungroup()
# Reassemble df_CDS_Diagnosis after processing of redundant diagnosis entries
df_CDS_Diagnosis <- df_CDS_Diagnosis %>%
filter(PatientCountInitialEntries == 1) %>%
bind_rows(df_Aux_Diagnosis_ClassifiedRedundancies) %>%
arrange(PatientID) %>%
group_by(PatientID) %>%
mutate(PatientCountDistinctEntries = n()) %>%
ungroup()
# For monitoring purposes, obtain:
# a) number of redundant diagnosis entries and
# b) number of patients that had redundant diagnosis entries
CountDiagnosisRedundancies <- sum(df_CDS_Diagnosis$CountRedundancies, na.rm = TRUE)
CountPatientsWithRedundancies <- df_CDS_Diagnosis %>%
filter(CountRedundancies > 0) %>%
pull(PatientID) %>%
n_distinct()
# Output monitoring message
cat("Found ", CountDiagnosisRedundancies, " redundancies related to ", CountPatientsWithRedundancies, " patient IDs.")
# Replace IDs (Original DiagnosisID and not newly composed one) of redundant diagnosis entries in related tables
# Get table of affected DiagnosisIDs
df_Aux_Diagnosis_IDMappingRedundancies <- df_CDS_Diagnosis %>%
ungroup() %>%
filter(CountRedundancies > 0) %>%
select(PatientID, RedundantOriginalIDs, OriginalDiagnosisID) %>%
unnest(cols = c(RedundantOriginalIDs)) %>%
rename(all_of(c(OldDiagnosisID = "RedundantOriginalIDs",
NewDiagnosisID = "OriginalDiagnosisID"))) %>%
filter(OldDiagnosisID != NewDiagnosisID) %>%
distinct()
# Replace IDs of redundant diagnosis entries in related tables
df_CDS_Metastasis <- df_CDS_Metastasis %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_CDS_MolecularDiagnostics <- df_CDS_MolecularDiagnostics %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_CDS_Progress <- df_CDS_Progress %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_CDS_RadiationTherapy <- df_CDS_RadiationTherapy %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_CDS_Staging <- df_CDS_Staging %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_CDS_Surgery <- df_CDS_Surgery %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_CDS_SystemicTherapy <- df_CDS_SystemicTherapy %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
# Remove columns of redundant IDs (not needed anymore)
df_CDS_Diagnosis <-  df_CDS_Diagnosis %>%
select(-c(RedundantIDs,
RedundantOriginalIDs,
CountRedundancies))
# Names of features that are required to compile rule calls from dsCCPhos::RuleSet_DiagnosisAssociation
PredictorFeatures_DiagnosisAssociation <- c("ICD10Code",
"ICD10CodeShort",
"ICD10Group",
"ICDOTopographyCode",
"ICDOTopographyCodeShort",
"LocalizationSide",
"ICDOMorphologyCode",
"ICDOMorphologyCodeShort",
"Grading")
# Compile rule calls (unevaluated dplyr::case_when-Statements) with dsCCPhos::CompileClassificationCall
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Call_IsLikelyAssociated <- CompileClassificationCall(TargetFeature = "IsLikelyAssociated",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = FALSE)
Call_InconsistencyCheck <- CompileClassificationCall(TargetFeature = "InconsistencyCheck",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = "No apparent inconsistency")
Call_ImplausibilityCheck <- CompileClassificationCall(TargetFeature = "ImplausibilityCheck",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = "No apparent implausibility")
Call_Relation_ICD10 <- CompileClassificationCall(TargetFeature = "Relation_ICD10",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = NA_character_)
Call_Relation_ICDOTopography <- CompileClassificationCall(TargetFeature = "Relation_ICDOTopography",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = NA_character_)
Call_Relation_LocalizationSide <- CompileClassificationCall(TargetFeature = "Relation_LocalizationSide",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = NA_character_)
Call_Relation_ICDOMorphology <- CompileClassificationCall(TargetFeature = "Relation_ICDOMorphology",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = NA_character_)
Call_Relation_Grading <- CompileClassificationCall(TargetFeature = "Relation_Grading",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = NA_character_)
Call_IsLikelyProgression <- CompileClassificationCall(TargetFeature = "IsLikelyProgression",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = NA)
Call_IsLikelyRecoding <- CompileClassificationCall(TargetFeature = "IsLikelyRecoding",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = dsCCPhos::RuleSet_DiagnosisAssociation,
RuleProfile = RuleProfile_DiagnosisAssociation,
ValueIfNoRuleMet = NA)
# Make list of rule calls to pass them to function
RuleCalls_DiagnosisAssociation <- list(IsLikelyAssociated = Call_IsLikelyAssociated,
InconsistencyCheck = Call_InconsistencyCheck,
ImplausibilityCheck = Call_ImplausibilityCheck,
Relation_ICD10 = Call_Relation_ICD10,
Relation_ICDOTopography = Call_Relation_ICDOTopography,
Relation_LocalizationSide = Call_Relation_LocalizationSide,
Relation_ICDOMorphology = Call_Relation_ICDOMorphology,
Relation_Grading = Call_Relation_Grading,
IsLikelyProgression = Call_IsLikelyProgression,
IsLikelyRecoding = Call_IsLikelyRecoding)
# Set up progress bar
CountProgressItems <- df_CDS_Diagnosis %>% filter(PatientCountDistinctEntries > 1) %>% pull(PatientID) %>% n_distinct()
ProgressBar <- progress_bar$new(format = "Classifying associated diagnosis entries [:bar] :percent in :elapsed  :spin",
total = CountProgressItems, clear = FALSE, width= 100)
# Filter patients with multiple distinct diagnosis entries and apply dsCCPhos::ClassifyDiagnosisAssociations()
df_Aux_Diagnosis_ClassifiedAssociations <- df_CDS_Diagnosis %>%
filter(PatientCountDistinctEntries > 1) %>%
group_by(PatientID) %>%
group_modify(~ ClassifyDiagnosisAssociation(DiagnosisEntries = .x,
RuleCalls = RuleCalls_DiagnosisAssociation,
ProgressBarObject = ProgressBar)) %>%
ungroup()
# Reassemble df_CDS_Diagnosis after processing of associated diagnosis entries
df_CDS_Diagnosis <- df_CDS_Diagnosis %>%
filter(PatientCountDistinctEntries == 1) %>%
mutate(ReferenceDiagnosisID = DiagnosisID) %>%
bind_rows(df_Aux_Diagnosis_ClassifiedAssociations) %>%
arrange(PatientID) %>%
relocate(c(PatientID, ReferenceDiagnosisID), .before = DiagnosisID)
# For monitoring purposes, obtain:
# a) number of associated diagnosis entries and
# b) number of patients that have associated diagnosis entries
CountAssociatedDiagnoses <- sum(df_CDS_Diagnosis$IsLikelyAssociated, na.rm = TRUE)
CountPatientsWithAssociatedDiagnoses <- df_Aux_Diagnosis_ClassifiedAssociations %>%
filter(IsLikelyAssociated == TRUE) %>%
pull(PatientID) %>%
n_distinct()
# Output monitoring message
cat("Classified ", CountAssociatedDiagnoses, " associated diagnosis entries related to ", CountPatientsWithAssociatedDiagnoses, " patient IDs.")
# Create table for DiagnosisID replacement in related tables
df_Aux_Diagnosis_IDMappingAssociations <- df_CDS_Diagnosis %>%
ungroup() %>%
select(PatientID, OriginalDiagnosisID, ReferenceDiagnosisID) %>%
rename(all_of(c(OldDiagnosisID = "OriginalDiagnosisID",
NewDiagnosisID = "ReferenceDiagnosisID"))) %>%
distinct()
# Replace DiagnosisIDs in all related tables with ReferenceDiagnosisID to associate entries
df_CDS_Metastasis <- df_CDS_Metastasis %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
df_CDS_MolecularDiagnostics <- df_CDS_MolecularDiagnostics %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
View(df_CDS_Surgery)
?cat
devtools::load_all(".")
# Replace DiagnosisIDs in all related tables with ReferenceDiagnosisID to associate entries
df_CDS_Metastasis <- df_CDS_Metastasis %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
df_CDS_MolecularDiagnostics <- df_CDS_MolecularDiagnostics %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
df_CDS_Progress <- df_CDS_Progress %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
df_CDS_RadiationTherapy <- df_CDS_RadiationTherapy %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
df_CDS_Staging <- df_CDS_Staging %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
df_CDS_Surgery <- df_CDS_Surgery %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
df_CDS_SystemicTherapy <- df_CDS_SystemicTherapy %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations)
rm(list=ls())
# Load needed packages
library(dsBase)
library(dsBaseClient)
library(dsCCPhos)
library(dsCCPhosClient)
library(DSLite)
library(resourcer)
load("./Development/Data/TestData/CCPTestData_A.RData")
load("./Development/Data/TestData/CCPTestData_B.RData")
load("./Development/Data/TestData/CCPTestData_C.RData")
Server_SiteA <- newDSLiteServer(tables = CCPTestData_A,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteB <- newDSLiteServer(tables = CCPTestData_B,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteC <- newDSLiteServer(tables = CCPTestData_C,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
# Returns an environment
LoginBuilder <- DSI::newDSLoginBuilder(.silent = FALSE)
LoginBuilder$append(server = "SiteA",
url = "Server_SiteA",
driver = "DSLiteDriver")
# Load needed packages
library(dsBase)
library(dsBaseClient)
library(dsCCPhos)
library(dsCCPhosClient)
library(DSLite)
library(resourcer)
load("./Development/Data/TestData/CCPTestData_A.RData")
load("./Development/Data/TestData/CCPTestData_B.RData")
load("./Development/Data/TestData/CCPTestData_C.RData")
Server_SiteA <- newDSLiteServer(tables = CCPTestData_A,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteB <- newDSLiteServer(tables = CCPTestData_B,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteC <- newDSLiteServer(tables = CCPTestData_C,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
# Returns an environment
LoginBuilder <- DSI::newDSLoginBuilder(.silent = FALSE)
LoginBuilder$append(server = "SiteA",
url = "Server_SiteA",
driver = "DSLiteDriver")
library(dsCCPhos)
LoginBuilder$append(server = "SiteB",
url = "Server_SiteB",
driver = "DSLiteDriver")
LoginBuilder$append(server = "SiteC",
url = "Server_SiteC",
driver = "DSLiteDriver")
# Returns a data frame of login data to servers
LoginData <- LoginBuilder$build()
# Get list of DSConnection objects of all servers
CCPConnections <- DSI::datashield.login(logins = LoginData,
assign = TRUE)
# Get info about installed packages on servers
DSI::datashield.pkg_status(conns = CCPConnections)
# Get table names of CCP core data set
CCPTableNames_Raw <- dsCCPhos::Meta_TableNames$TableName_Raw
CCPTableNames_Curated <- dsCCPhos::Meta_TableNames$TableName_Curated
# Check if all tables are accessible on all servers
ls_TableCheck <- purrr::map(as.list(CCPTableNames_Curated),
function(tbl)
{
datashield.table_status(conns = CCPConnections,
table = tbl)
})
# Turn list into data.frame
df_TableCheck <- do.call(rbind, ls_TableCheck)
# Make tables from data repository accessible in R session
for(i in 1:length(CCPTableNames_Curated))
{
datashield.assign(conns = CCPConnections,
symbol = CCPTableNames_Curated[i],
value = CCPTableNames_Curated[i])
}
# Consolidate all raw data tables in one list object called "RawDataSet"
ds.list(x = CCPTableNames_Curated,
newobj = "RawDataSet",
datasources = CCPConnections)
# Make sure assignment was successful on all servers
ds.GetObjectInfo(ObjectName = "RawDataSet",
DataSources = CCPConnections)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS)
dsCCPhosClient::ds.CurateData(Name_RawDataSet = "RawDataSet",
Name_Output = "CurationOutput",
DataSources = CCPConnections)
# Get Curation reports
CurationReports <- ds.GetCurationReport(Name_CurationOutput = "CurationOutput",
DataSources = CCPConnections)
View(CurationReports$SiteA$Monitor_Staging)
View(CurationReports$SiteB$Monitor_Staging)
rm(list=ls())
library(dsCCPhos)
# Load test data into WD
load("./Development/Data/TestData/CCPTestData_B.RData")
# Create virtual data base with test data
DBConnection <- MakeTestDB(CCPTestData_B)
# Load raw test data from data base into WD
RawDataSet <- LoadRawData(DBConnection)
RuleProfile_RawDataTransformation = "Default"
RuleProfile_DiagnosisRedundancy = "Default"
RuleProfile_DiagnosisAssociation = "Default"
# Curate data
CurationOutput <- dsCCPhos::CurateDataDS(Name_RawDataSet = "RawDataSet",
RuleProfile_RawDataTransformation = "Default",
RuleProfile_DiagnosisRedundancy = "Default",
RuleProfile_DiagnosisAssociation = "Default")
devtools::load_all(".")
# Curate data
CurationOutput <- dsCCPhos::CurateDataDS(Name_RawDataSet = "RawDataSet",
RuleProfile_RawDataTransformation = "Default",
RuleProfile_DiagnosisRedundancy = "Default",
RuleProfile_DiagnosisAssociation = "Default")
View(CurationOutput$CurationReport$Monitor_Staging)
View(CurationOutput$CuratedDataSet$Staging)
View(CurationOutput$CuratedDataSet$Diagnosis)
# Try out data augmentation method
dsCCPhosClient::ds.AugmentData(Name_CurationOutput = "CurationOutput",
Name_Output = "AugmentationOutput",
DataSources = CCPConnections)
# Load needed packages
library(dsBase)
library(dsBaseClient)
library(dsCCPhos)
library(dsCCPhosClient)
library(DSLite)
library(resourcer)
load("./Development/Data/TestData/CCPTestData_A.RData")
load("./Development/Data/TestData/CCPTestData_B.RData")
load("./Development/Data/TestData/CCPTestData_C.RData")
Server_SiteA <- newDSLiteServer(tables = CCPTestData_A,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteB <- newDSLiteServer(tables = CCPTestData_B,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteC <- newDSLiteServer(tables = CCPTestData_C,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
# Returns an environment
LoginBuilder <- DSI::newDSLoginBuilder(.silent = FALSE)
LoginBuilder$append(server = "SiteA",
url = "Server_SiteA",
driver = "DSLiteDriver")
LoginBuilder$append(server = "SiteB",
url = "Server_SiteB",
driver = "DSLiteDriver")
LoginBuilder$append(server = "SiteC",
url = "Server_SiteC",
driver = "DSLiteDriver")
# Returns a data frame of login data to servers
LoginData <- LoginBuilder$build()
# Get list of DSConnection objects of all servers
CCPConnections <- DSI::datashield.login(logins = LoginData,
assign = TRUE)
# Get table names of CCP core data set
CCPTableNames_Raw <- dsCCPhos::Meta_TableNames$TableName_Raw
CCPTableNames_Curated <- dsCCPhos::Meta_TableNames$TableName_Curated
# Check if all tables are accessible on all servers
ls_TableCheck <- purrr::map(as.list(CCPTableNames_Curated),
function(tbl)
{
datashield.table_status(conns = CCPConnections,
table = tbl)
})
# Turn list into data.frame
df_TableCheck <- do.call(rbind, ls_TableCheck)
# Make tables from data repository accessible in R session
for(i in 1:length(CCPTableNames_Curated))
{
datashield.assign(conns = CCPConnections,
symbol = CCPTableNames_Curated[i],
value = CCPTableNames_Curated[i])
}
# Consolidate all raw data tables in one list object called "RawDataSet"
ds.list(x = CCPTableNames_Curated,
newobj = "RawDataSet",
datasources = CCPConnections)
# Make sure assignment was successful on all servers
ds.GetObjectInfo(ObjectName = "RawDataSet",
DataSources = CCPConnections)
datashield.errors()
DSI::datashield.logout(CCPConnections)
# Load needed packages
library(dsBase)
library(dsBaseClient)
library(dsCCPhos)
library(dsCCPhosClient)
library(DSLite)
library(resourcer)
load("./Development/Data/TestData/CCPTestData_A.RData")
load("./Development/Data/TestData/CCPTestData_B.RData")
load("./Development/Data/TestData/CCPTestData_C.RData")
Server_SiteA <- newDSLiteServer(tables = CCPTestData_A,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteB <- newDSLiteServer(tables = CCPTestData_B,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteC <- newDSLiteServer(tables = CCPTestData_C,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
# Returns an environment
LoginBuilder <- DSI::newDSLoginBuilder(.silent = FALSE)
LoginBuilder$append(server = "SiteA",
url = "Server_SiteA",
driver = "DSLiteDriver")
LoginBuilder$append(server = "SiteB",
url = "Server_SiteB",
driver = "DSLiteDriver")
LoginBuilder$append(server = "SiteC",
url = "Server_SiteC",
driver = "DSLiteDriver")
# Returns a data frame of login data to servers
LoginData <- LoginBuilder$build()
# Get list of DSConnection objects of all servers
CCPConnections <- DSI::datashield.login(logins = LoginData,
assign = TRUE)
# Alternatively use DSI::datashield.method_status() to get more comparable overview
# AGGREGATE functions
DSI::datashield.method_status(conns = CCPConnections,
type = "aggregate")
# List all available dataSHIELD methods on servers
DSI::datashield.methods(conns = CCPConnections)
DSI::datashield.logout(CCPConnections)
rm(list=ls())
# Load needed packages
library(dsBase)
library(dsBaseClient)
library(dsCCPhos)
library(dsCCPhosClient)
library(DSLite)
library(resourcer)
load("./Development/Data/TestData/CCPTestData_A.RData")
load("./Development/Data/TestData/CCPTestData_B.RData")
load("./Development/Data/TestData/CCPTestData_C.RData")
library(dsCCPhos)
Server_SiteA <- newDSLiteServer(tables = CCPTestData_A,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteB <- newDSLiteServer(tables = CCPTestData_B,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
Server_SiteC <- newDSLiteServer(tables = CCPTestData_C,
config = DSLite::defaultDSConfiguration(include = c("dsBase",
"dsCCPhos")))
# Returns an environment
LoginBuilder <- DSI::newDSLoginBuilder(.silent = FALSE)
LoginBuilder$append(server = "SiteA",
url = "Server_SiteA",
driver = "DSLiteDriver")
LoginBuilder$append(server = "SiteB",
url = "Server_SiteB",
driver = "DSLiteDriver")
LoginBuilder$append(server = "SiteC",
url = "Server_SiteC",
driver = "DSLiteDriver")
# Returns a data frame of login data to servers
LoginData <- LoginBuilder$build()
# Get list of DSConnection objects of all servers
CCPConnections <- DSI::datashield.login(logins = LoginData,
assign = TRUE)
# List all available dataSHIELD methods on servers
DSI::datashield.methods(conns = CCPConnections)
# Get table names of CCP core data set
CCPTableNames_Raw <- dsCCPhos::Meta_TableNames$TableName_Raw
CCPTableNames_Curated <- dsCCPhos::Meta_TableNames$TableName_Curated
# Check if all tables are accessible on all servers
ls_TableCheck <- purrr::map(as.list(CCPTableNames_Curated),
function(tbl)
{
datashield.table_status(conns = CCPConnections,
table = tbl)
})
# Turn list into data.frame
df_TableCheck <- do.call(rbind, ls_TableCheck)
# Make tables from data repository accessible in R session
for(i in 1:length(CCPTableNames_Curated))
{
datashield.assign(conns = CCPConnections,
symbol = CCPTableNames_Curated[i],
value = CCPTableNames_Curated[i])
}
# Consolidate all raw data tables in one list object called "RawDataSet"
ds.list(x = CCPTableNames_Curated,
newobj = "RawDataSet",
datasources = CCPConnections)
# Make sure assignment was successful on all servers
ds.GetObjectInfo(ObjectName = "RawDataSet",
DataSources = CCPConnections)
# Transform Raw Data Set (RDS) into Curated Data Set (CDS)
dsCCPhosClient::ds.CurateData(Name_RawDataSet = "RawDataSet",
Name_Output = "CurationOutput",
DataSources = CCPConnections)
# Get Curation reports
CurationReports <- ds.GetCurationReport(Name_CurationOutput = "CurationOutput",
DataSources = CCPConnections)
# Exemplary look at a curation report table
View(CurationReports$SiteA$Monitor_Staging)
# Try out data augmentation method
dsCCPhosClient::ds.AugmentData(Name_CurationOutput = "CurationOutput",
Name_Output = "AugmentationOutput",
DataSources = CCPConnections)
datashield.errors()
devtools::load_all(".")
