ValueCountsRecoded,
ValueCountsFinal)
{
if (nrow(TransformationTracksSummary) > 0)
{
TransformationTracksSummary %>%
left_join(ValueCountsRaw, by = c("Feature", "Value_Raw")) %>%
left_join(ValueCountsHarmonized, by = c("Feature", "Value_Harmonized")) %>%
left_join(ValueCountsRecoded, by = c("Feature", "Value_Recoded")) %>%
left_join(ValueCountsFinal, by = c("Feature", "Value_Final")) %>%
mutate(Count_Harmonized = case_when(IsOccurring == FALSE ~ NA,
TRUE ~ Count_Harmonized),
Count_Recoded = case_when(IsOccurring == FALSE ~ NA,
TRUE ~ Count_Recoded),
Count_Final = case_when(IsOccurring == FALSE ~ NA,
TRUE ~ Count_Final)) %>%
arrange(Feature,
desc(IsOccurring),
desc(IsEligible_Raw),
desc(IsEligible_Harmonized),
Value_Raw)
}
else { return(NULL) }
})
# Create overview of value eligibility in different transformation stages
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_EligibilityOverviews <- purrr::pmap(.l = list(ls_TransformationMonitors,
ls_MonitorMetaData),
.f = function(MonitorData,
MonitorMetaData)
{
if (!(purrr::is_empty(MonitorData) | is.null(MonitorData)))
{
# Filter out features that are not meant to be monitored, e.g. do not have applicable eligibility criteria
MonitorData <- MonitorData %>%
filter(Feature %in% names(MonitorMetaData))
SummaryRaw <- MonitorData %>%
group_by(Feature, IsEligible_Raw) %>%
summarize(Raw = sum(Count_Raw, na.rm = TRUE)) %>%
rename(Eligibility = IsEligible_Raw)
SummaryHarmonized <- MonitorData %>%
distinct(pick(Feature, Value_Harmonized), .keep_all = TRUE) %>%
group_by(Feature, IsEligible_Harmonized) %>%
summarize(Harmonized = sum(Count_Harmonized, na.rm = TRUE)) %>%
rename(Eligibility = IsEligible_Harmonized)
SummaryRecoded <- MonitorData %>%
distinct(pick(Feature, Value_Recoded), .keep_all = TRUE) %>%
group_by(Feature, IsEligible_Recoded) %>%
summarize(Recoded = sum(Count_Recoded, na.rm = TRUE)) %>%
rename(Eligibility = IsEligible_Recoded)
SummaryFinal <- MonitorData %>%
distinct(pick(Feature, Value_Final), .keep_all = TRUE) %>%
group_by(Feature, IsEligible_Final) %>%
summarize(Final = sum(Count_Final, na.rm = TRUE)) %>%
rename(Eligibility = IsEligible_Final)
Overview <- SummaryRaw %>%
full_join(SummaryHarmonized, by = join_by(Feature, Eligibility)) %>%
full_join(SummaryRecoded, by = join_by(Feature, Eligibility)) %>%
full_join(SummaryFinal, by = join_by(Feature, Eligibility)) %>%
arrange(Feature, desc(Eligibility)) %>%
mutate(Eligibility = case_match(Eligibility,
TRUE ~ "Eligible",
FALSE ~ "Ineligible",
NA ~ "Missing"))
# Get tibble of all combinations of occurring features and eligibility category
AllCombinations <- tibble(Feature = rep(unique(Overview$Feature), each = 3),
Eligibility = rep(c("Eligible", "Ineligible", "Missing"), times = length(unique(Overview$Feature))))
# Finalize overview
Overview <- Overview %>%
right_join(AllCombinations, by = join_by(Feature, Eligibility)) %>%
mutate(across(c(Raw, Harmonized, Recoded, Final), ~ case_when(is.na(.x) ~ 0, .default = .x))) %>%       # Turn all NAs into 0 in count columns
group_by(Feature) %>%
mutate(across(c(Raw, Harmonized, Recoded, Final), ~ .x / sum(.x), .names = "{.col}_Proportional")) %>%      # Create proportional value columns
ungroup() %>%
arrange(Feature, factor(Eligibility, levels = c("Eligible", "Ineligible", "Missing")))
}
else { return(data.frame()) }
})
# Create overview of value eligibility in different transformation stages
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_ValueSetOverviews <- purrr::map(.x = ls_TransformationMonitors,
.f = function(MonitorData)
{
if (!purrr::is_empty(MonitorData))
{
ValueSets <- list()
ValueSets$Raw <- MonitorData %>%
select(Feature, Value_Raw, IsOccurring, IsEligible_Raw, Count_Raw) %>%
group_by(Feature) %>%
mutate(Proportion_Raw = Count_Raw / sum(Count_Raw, na.rm = TRUE)) %>%
ungroup()
ValueSets$Harmonized <- MonitorData %>%
group_by(Feature, Value_Harmonized, IsEligible_Harmonized) %>%
summarize(Count_Harmonized = sum(Count_Harmonized, na.rm = TRUE)) %>%
ungroup() %>%
distinct(Feature, Value_Harmonized, .keep_all = TRUE) %>%
group_by(Feature) %>%
mutate(Proportion_Harmonized = Count_Harmonized / sum(Count_Harmonized, na.rm = TRUE)) %>%
ungroup()
ValueSets$Recoded <- MonitorData %>%
group_by(Feature, Value_Recoded, IsEligible_Recoded) %>%
summarize(Count_Recoded = sum(Count_Recoded, na.rm = TRUE)) %>%
ungroup() %>%
distinct(Feature, Value_Recoded, .keep_all = TRUE) %>%
group_by(Feature) %>%
mutate(Proportion_Recoded = Count_Recoded / sum(Count_Recoded, na.rm = TRUE)) %>%
ungroup()
ValueSets$Final <- MonitorData %>%
group_by(Feature, Value_Final, IsEligible_Final) %>%
summarize(Count_Final = sum(Count_Final, na.rm = TRUE)) %>%
ungroup() %>%
distinct(Feature, Value_Final, .keep_all = TRUE) %>%
group_by(Feature) %>%
mutate(Proportion_Final = Count_Final / sum(Count_Final, na.rm = TRUE)) %>%
ungroup()
return(ValueSets)
}
else { return(list()) }
})
# Delete artificial "TrackID"-column from data frames (not needed anymore)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
try(df_BioSampling <- df_BioSampling %>% select(-TrackID))
try(df_Diagnosis <- df_Diagnosis %>% select(-TrackID))
try(df_Histology <- df_Histology %>% select(-TrackID))
try(df_Metastasis <- df_Metastasis %>% select(-TrackID))
try(df_MolecularDiagnostics <- df_MolecularDiagnostics %>% select(-TrackID))
try(df_Patient <- df_Patient %>% select(-TrackID))
try(df_Progress <- df_Progress %>% select(-TrackID))
try(df_RadiationTherapy <- df_RadiationTherapy %>% select(-TrackID))
try(df_Staging <- df_Staging %>% select(-TrackID))
try(df_Surgery <- df_Surgery %>% select(-TrackID))
try(df_SystemicTherapy <- df_SystemicTherapy %>% select(-TrackID))
try(ProgressBar$tick())
try(ProgressBar$terminate())
# Print info message
cli::cat_bullet("Data transformation monitors are stored in 'CurationReport$Transformation'", bullet = "info")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MODULE 4)  Process diagnosis data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   A) Joining of df_Diagnosis and df_Histology to get coherent diagnosis data
#   B) Classification and removal of redundant diagnosis entries
#        - Afterwards update Diagnosis IDs in related tables
#   C) Classification and bundling of associated diagnosis entries
#        - Afterwards update Diagnosis IDs in related tables
#   D) Reconstruct df_Histology from df_Diagnosis
#-------------------------------------------------------------------------------
# Module 4 A) Join df_Diagnosis and df_Histology
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   - Create composed ID ('DiagnosisID / HistologyID')
#   - Add auxiliary features for filtering purposes
#-------------------------------------------------------------------------------
df_Diagnosis <- df_Diagnosis %>%
left_join(df_Histology, by = join_by(PatientID, DiagnosisID)) %>%
mutate(OriginalDiagnosisID = DiagnosisID,
DiagnosisID = paste0(DiagnosisID, "/", HistologyID)) %>%
relocate(DiagnosisID, .after = PatientID) %>%
group_by(PatientID) %>%
mutate(PatientCountInitialEntries = n()) %>%
ungroup()
# Module 4 B) Classification and removal of redundant entries
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   - In patients with multiple diagnosis entries:
#     Use dsCCPhos-function ClassifyDiagnosisRedundancy() to identify and consolidate redundant diagnosis entries
#   - Rules for classification of redundancy are defined in customizable data object delivered with dsCCPhos
#   - Replace redundant DiagnosisIDs in all related tables
#-------------------------------------------------------------------------------
# Compile rule calls from data in RuleSet_DiagnosisRedundancy.S using dsCCPhos::CompileClassificationCall
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Names of features that are required to compile rule calls from RuleSet_DiagnosisRedundancy.S
PredictorFeatures_DiagnosisRedundancy = c("CountDeviatingValues",
"InitialDiagnosisDate",
"ICD10Code",
"ICDOTopographyCode",
"LocalizationSide",
"HistologyDate",
"ICDOMorphologyCode",
"Grading")
# Pass required information to dsCCPhos::CompileClassificationCall to compile rull calls (dplyr::case_when-Statements)
Call_IsLikelyRedundant <- CompileClassificationCall(TargetFeature = "IsLikelyRedundant",
PredictorFeatures = PredictorFeatures_DiagnosisRedundancy,
RuleSet = RuleSet_DiagnosisRedundancy.S,
RuleProfile = RuleProfile_DiagnosisRedundancy.S,
ValueIfNoRuleMet = FALSE)
# Make list of rule calls to pass them to function
RuleCalls_DiagnosisRedundancy <- list(IsLikelyRedundant = Call_IsLikelyRedundant)
# Set up progress bar
CountProgressItems <- df_Diagnosis %>% filter(PatientCountInitialEntries > 1) %>% pull(PatientID) %>% n_distinct()
ProgressBar <- progress_bar$new(format = "Classifying redundant diagnosis entries [:bar] :percent in :elapsed  :spin",
total = CountProgressItems, clear = FALSE, width= 100)
# Filter patients with multiple diagnosis entries and apply dsCCPhos::ClassifyDiagnosisRedundancy()
df_Aux_Diagnosis_ClassifiedRedundancies <- df_Diagnosis %>%
filter(PatientCountInitialEntries > 1) %>%
group_by(PatientID) %>%
group_modify(~ ClassifyDiagnosisRedundancy(DiagnosisEntries = .x,
RuleCalls = RuleCalls_DiagnosisRedundancy,
ProgressBarObject = ProgressBar)) %>%
ungroup()
# Reassemble df_Diagnosis after processing of redundant diagnosis entries
df_Diagnosis <- df_Diagnosis %>%
filter(PatientCountInitialEntries == 1) %>%
bind_rows(df_Aux_Diagnosis_ClassifiedRedundancies) %>%
arrange(PatientID) %>%
group_by(PatientID) %>%
mutate(PatientCountDistinctEntries = n()) %>%
ungroup()
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MONITORING: Redundant diagnosis entries
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# a) Number of redundant diagnosis entries and
# b) Number of patients that had redundant diagnosis entries
CountDiagnosisRedundancies <- sum(df_Diagnosis$CountRedundancies, na.rm = TRUE)
CountPatientsWithDiagnosisRedundancies <- df_Diagnosis %>%
filter(CountRedundancies > 0) %>%
pull(PatientID) %>%
n_distinct()
# Print message for live monitoring in local tests
Message <- paste0("Found ", CountDiagnosisRedundancies, " redundancies related to ", CountPatientsWithDiagnosisRedundancies, " patient IDs.")
cli::cat_bullet(Message, bullet = "info")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Replace IDs (Original DiagnosisID and not newly composed one) of redundant diagnosis entries in related tables
# Get table of affected DiagnosisIDs
df_Aux_Diagnosis_IDMappingRedundancies <- df_Diagnosis %>%
ungroup() %>%
filter(CountRedundancies > 0) %>%
select(PatientID, RedundantOriginalIDs, OriginalDiagnosisID) %>%
unnest(cols = c(RedundantOriginalIDs)) %>%
rename(all_of(c(OldDiagnosisID = "RedundantOriginalIDs",
NewDiagnosisID = "OriginalDiagnosisID"))) %>%
filter(OldDiagnosisID != NewDiagnosisID) %>%
distinct()
# Replace IDs of redundant diagnosis entries in related tables
df_Metastasis <- df_Metastasis %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_MolecularDiagnostics <- df_MolecularDiagnostics %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_Progress <- df_Progress %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_RadiationTherapy <- df_RadiationTherapy %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_Staging <- df_Staging %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_Surgery <- df_Surgery %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
df_SystemicTherapy <- df_SystemicTherapy %>% ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingRedundancies)
# Remove columns of redundant IDs (not needed anymore)
df_Diagnosis <-  df_Diagnosis %>%
select(-c(RedundantIDs,
RedundantOriginalIDs,
CountRedundancies))
# Module 4 C) Classify associations between diagnosis entries
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#   - In patients with multiple distinct diagnosis entries:
#     Use dsCCPhos-function ClassifyDiagnosisAssociations() to plausibly distinguish pseudo-different from actually different diagnoses
#   - Rules for classification of associated diagnosis entries are defined in customizable data object delivered with dsCCPhos
#   - Replace DiagnosisIDs in all related tables with ReferenceDiagnosisID
#-------------------------------------------------------------------------------
# Names of features that are required to compile rule calls from RuleSet_DiagnosisAssociation.S
PredictorFeatures_DiagnosisAssociation <- c("ICD10Code",
"ICD10CodeShort",
"ICD10Group",
"ICDOTopographyCode",
"ICDOTopographyCodeShort",
"LocalizationSide",
"ICDOMorphologyCode",
"ICDOMorphologyCodeShort",
"Grading")
# Compile rule calls (unevaluated dplyr::case_when-Statements) with dsCCPhos::CompileClassificationCall
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Call_IsLikelyAssociated <- CompileClassificationCall(TargetFeature = "IsLikelyAssociated",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = FALSE)
Call_InconsistencyCheck <- CompileClassificationCall(TargetFeature = "InconsistencyCheck",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = "No apparent inconsistency")
Call_ImplausibilityCheck <- CompileClassificationCall(TargetFeature = "ImplausibilityCheck",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = "No apparent implausibility")
Call_Relation_ICD10 <- CompileClassificationCall(TargetFeature = "Relation_ICD10",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = NA_character_)
Call_Relation_ICDOTopography <- CompileClassificationCall(TargetFeature = "Relation_ICDOTopography",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = NA_character_)
Call_Relation_LocalizationSide <- CompileClassificationCall(TargetFeature = "Relation_LocalizationSide",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = NA_character_)
Call_Relation_ICDOMorphology <- CompileClassificationCall(TargetFeature = "Relation_ICDOMorphology",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = NA_character_)
Call_Relation_Grading <- CompileClassificationCall(TargetFeature = "Relation_Grading",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = NA_character_)
Call_IsLikelyProgression <- CompileClassificationCall(TargetFeature = "IsLikelyProgression",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = NA)
Call_IsLikelyRecoding <- CompileClassificationCall(TargetFeature = "IsLikelyRecoding",
PredictorFeatures = PredictorFeatures_DiagnosisAssociation,
RuleSet = RuleSet_DiagnosisAssociation.S,
RuleProfile = RuleProfile_DiagnosisAssociation.S,
ValueIfNoRuleMet = NA)
# Make list of rule calls to pass them to function
RuleCalls_DiagnosisAssociation <- list(IsLikelyAssociated = Call_IsLikelyAssociated,
InconsistencyCheck = Call_InconsistencyCheck,
ImplausibilityCheck = Call_ImplausibilityCheck,
Relation_ICD10 = Call_Relation_ICD10,
Relation_ICDOTopography = Call_Relation_ICDOTopography,
Relation_LocalizationSide = Call_Relation_LocalizationSide,
Relation_ICDOMorphology = Call_Relation_ICDOMorphology,
Relation_Grading = Call_Relation_Grading,
IsLikelyProgression = Call_IsLikelyProgression,
IsLikelyRecoding = Call_IsLikelyRecoding)
# Set up progress bar
CountProgressItems <- df_Diagnosis %>% filter(PatientCountDistinctEntries > 1) %>% pull(PatientID) %>% n_distinct()
ProgressBar <- progress_bar$new(format = "Classifying associated diagnosis entries [:bar] :percent in :elapsed  :spin",
total = CountProgressItems, clear = FALSE, width= 100)
# Filter patients with multiple distinct diagnosis entries and apply dsCCPhos::ClassifyDiagnosisAssociations()
df_Aux_Diagnosis_ClassifiedAssociations <- df_Diagnosis %>%
filter(PatientCountDistinctEntries > 1) %>%
group_by(PatientID) %>%
group_modify(~ ClassifyDiagnosisAssociation(DiagnosisEntries = .x,
RuleCalls = RuleCalls_DiagnosisAssociation,
ProgressBarObject = ProgressBar)) %>%
ungroup()
# Reassemble df_Diagnosis after processing of associated diagnosis entries
df_Diagnosis <- df_Diagnosis %>%
filter(PatientCountDistinctEntries == 1) %>%
mutate(ReferenceDiagnosisID = DiagnosisID,
IsLikelyAssociated = FALSE) %>%
bind_rows(df_Aux_Diagnosis_ClassifiedAssociations) %>%
mutate(IsReferenceEntry = (ReferenceDiagnosisID == DiagnosisID),
.after = DiagnosisID) %>%
arrange(PatientID) %>%
relocate(c(PatientID, ReferenceDiagnosisID), .before = DiagnosisID) %>%
rename(all_of(c(SubDiagnosisID = "DiagnosisID",
DiagnosisID = "ReferenceDiagnosisID")))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# MONITORING: Associated diagnosis entries
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# a) Number of associated diagnosis entries and
# b) Number of patients that have associated diagnosis entries
CountDiagnosisAssociations <- sum(df_Diagnosis$IsLikelyAssociated, na.rm = TRUE)
CountPatientsWithDiagnosisAssociations <- df_Aux_Diagnosis_ClassifiedAssociations %>%
filter(IsLikelyAssociated == TRUE) %>%
pull(PatientID) %>%
n_distinct()
# Print message for live monitoring in local tests
Message <- paste0("Classified ", CountDiagnosisAssociations, " associated diagnosis entries related to ", CountPatientsWithDiagnosisAssociations, " patient IDs.")
cli::cat_bullet(Message, bullet = "info")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Create table for DiagnosisID replacement in related tables
df_Aux_Diagnosis_IDMappingAssociations <- df_Diagnosis %>%
ungroup() %>%
select(PatientID, OriginalDiagnosisID, DiagnosisID, SubDiagnosisID) %>%
rename(all_of(c(OldDiagnosisID = "OriginalDiagnosisID",
NewDiagnosisID = "DiagnosisID"))) %>%
distinct()
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Update related tables
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#     - Replace DiagnosisIDs to associate entries (and add SubDiagnosisIDs in same move)
#     - Rearrange column order
#-------------------------------------------------------------------------------
df_Metastasis <- df_Metastasis %>%
ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations) %>%
relocate(c(PatientID, DiagnosisID, SubDiagnosisID), .before = MetastasisID)
if (nrow(df_MolecularDiagnostics) > 0)
{
df_MolecularDiagnostics <- df_MolecularDiagnostics %>%
ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations) %>%
relocate(c(PatientID, DiagnosisID, SubDiagnosisID), .before = MolecularDiagnosticsID)
}
df_Progress <- df_Progress %>%
ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations) %>%
relocate(c(PatientID, DiagnosisID, SubDiagnosisID), .before = ProgressID)
df_RadiationTherapy <- df_RadiationTherapy %>%
ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations) %>%
relocate(c(PatientID, DiagnosisID, SubDiagnosisID), .before = RadiationTherapyID)
df_Staging <- df_Staging %>%
ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations) %>%
relocate(c(PatientID, DiagnosisID, SubDiagnosisID), .before = StagingID)
df_Surgery <- df_Surgery %>%
ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations) %>%
relocate(c(PatientID, DiagnosisID, SubDiagnosisID), .before = SurgeryID)
df_SystemicTherapy <- df_SystemicTherapy %>%
ReplaceDiagnosisIDs(IDMapping = df_Aux_Diagnosis_IDMappingAssociations) %>%
relocate(c(PatientID, DiagnosisID, SubDiagnosisID), .before = SystemicTherapyID)
# Module 4 D) Reconstruct df_Histology from df_Diagnosis
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Remove OriginalDiagnosisID column (not needed anymore)
df_Diagnosis <-  df_Diagnosis %>%
select(-OriginalDiagnosisID)
# Reconstruct df_Histology
df_Histology <- df_Diagnosis %>%
select(all_of(c("SubDiagnosisID", names(df_Histology)))) %>%
relocate(c(PatientID, DiagnosisID, SubDiagnosisID), .before = HistologyID)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Re-pack data frames into list to get compact Curated Data Set (CDS) object
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# - Conversion from tibble to data.frame (if necessary), because dataSHIELD can handle data.frames better
#-------------------------------------------------------------------------------
ls_CuratedDataSet <- list(BioSampling = as.data.frame(df_BioSampling),
Diagnosis = as.data.frame(df_Diagnosis),
Histology = as.data.frame(df_Histology),
Metastasis = as.data.frame(df_Metastasis),
MolecularDiagnostics = as.data.frame(df_MolecularDiagnostics),
Patient = as.data.frame(df_Patient),
Progress = as.data.frame(df_Progress),
RadiationTherapy = as.data.frame(df_RadiationTherapy),
Staging = as.data.frame(df_Staging),
Surgery = as.data.frame(df_Surgery),
SystemicTherapy = as.data.frame(df_SystemicTherapy))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define content of CurationReport
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ls_CurationReport <- list(UnlinkedEntries = CountUnlinkedEntries,      # Named vector
Transformation = list(Monitors = ls_TransformationMonitors,      # List of lists
EligibilityOverviews = ls_EligibilityOverviews,
ValueSetOverviews = ls_ValueSetOverviews),
DiagnosisClassification = c(DiagnosisRedundancies = CountDiagnosisRedundancies,      # Named vector
PatientsWithDiagnosisRedundancies = CountPatientsWithDiagnosisRedundancies,
DiagnosisAssociations = CountDiagnosisAssociations,
PatientsWithDiagnosisAssociations = CountPatientsWithDiagnosisAssociations))
Messages$Completed <- TRUE
devtools::load_all(".")
rm(list=ls())
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
RuleProfile_RawDataHarmonization.S = "Default",
RuleProfile_DiagnosisRedundancy.S = "Default",
RuleProfile_DiagnosisAssociation.S = "Default")
devtools::load_all(".")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
RuleProfile_RawDataHarmonization.S = "Default",
RuleProfile_DiagnosisRedundancy.S = "Default",
RuleProfile_DiagnosisAssociation.S = "Default")
rm(list=ls())
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
Meta_FeatureNames <- read_excel(path = "./Development/Data/MetaData/MetaDataCCP.xlsx",
sheet = "FeatureNames")
# Save data in .rda-file and make it part of package
use_data(Meta_FeatureNames, overwrite = TRUE)
Meta_ValueSets <- read_excel(path = "./Development/Data/MetaData/MetaDataCCP.xlsx",
sheet = "ValueSets")
# Save data in .rda-file and make it part of package
use_data(Meta_ValueSets, overwrite = TRUE)
rm(list=ls())
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Load CCP test data as raw data set
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#RawDataSet <- readRDS(file = "./Development/Data/RealData/CCPRealData_Frankfurt.rds")
#OldTestData <- readRDS(file = "./Development/Data/TestData/OldTestData/CCPTestData.rds")
RawDataSet <- readRDS(file = "./Development/Data/TestData/CCPTestData.rds")
# Rename tables of RawDataSet (the names are also changed when tables are being loaded into R server sessions)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vc_Lookup <- paste0("RDS_", dsCCPhos::Meta_TableNames$TableName_Curated)
names(vc_Lookup) <- dsCCPhos::Meta_TableNames$TableName_Raw
names(RawDataSet) <- sapply(names(RawDataSet),
function(TableName) { vc_Lookup[TableName] })
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Curate data
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CurationOutput <- dsCCPhos::CurateDataDS(RawDataSetName.S = "RawDataSet",
RuleProfile_RawDataHarmonization.S = "Default",
RuleProfile_DiagnosisRedundancy.S = "Default",
RuleProfile_DiagnosisAssociation.S = "Default")
CurationOutput$CurationReport$UnlinkedEntries
View(CurationOutput$CurationReport$Transformation$Monitors$Staging)
View(CurationOutput$CurationReport$Transformation$EligibilityOverviews$Staging)
View(CurationOutput$CurationReport$Transformation$ValueSetOverviews$Staging$Harmonized)
CuratedDataSet <- CurationOutput$CuratedDataSet
View(CuratedDataSet$Patient)
# Augment data
AugmentationOutput <- dsCCPhos::AugmentDataDS(CuratedDataSetName.S = "CuratedDataSet")
devtools::load_all(".")
# Augment data
AugmentationOutput <- dsCCPhos::AugmentDataDS(CuratedDataSetName.S = "CuratedDataSet")
ADS <- AugmentationOutput$AugmentedDataSet
View(ADS$Patients)
View(ADS$Events)
View(ADS$Diagnoses)
SampleStatistics <- GetSampleStatisticsDS(TableName.S = "ADS$Patients",
FeatureName.S = "LastVitalStatus")
View(ADS$Patients)
devtools::load_all(".")
